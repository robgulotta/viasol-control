Below is a single “canvas” you can keep open while you work. Top is **rules + your existing code architecture** (highest priority), then it slopes down into comms/MQTT/gateway/hardware.

---

## Canvas: Solar Diversion Controller Implementation Plan

### A) Rules system vNext (do this first)

#### A1) Timing + stability controls (stop flapping, stop over-checking)

* [ ] **Per-rule eval frequency limit**: `minEvalPeriodMs` (skip eval until time elapsed)
* [ ] **Per-rule cooldown / lockout (“latency”)**: after a state change or trigger, don’t allow retrigger until `cooldownMs`
* [ ] **Separate “duration” vs “cooldown”**

  * [ ] `durationMs`: hold asserted output/action active
  * [ ] `cooldownMs`: ignore changes/retriggers for a while
* [ ] Optional stability tools (highly recommended)

  * [ ] **Debounce / stableForMs** for boolean conditions (sun-is-out, etc.)
  * [ ] **Hysteresis** for thresholds (SOC/temp) to prevent oscillation

#### A2) Modular rule construction (conditions → expressions → actions)

* [ ] **Condition primitives (“IF blocks”)** as standalone objects

  * [ ] Typed params (thresholds, sensor keys, comparison ops)
  * [ ] Eval returns bool (later: tri-state if you want “unknown”)
* [ ] **Expression tree / logic graph**

  * [ ] `AND(children[])`, `OR(children[])`, `NOT(child)`
  * [ ] Leaves reference condition IDs
  * [ ] Nested groups: (A AND B) OR (C AND (NOT D))
* [ ] **Actions** as separate objects

  * [ ] `SetOutput(key, value)` (on/off, PWM %, mode)
  * [ ] Duration handling per action (or per rule)
  * [ ] Optional: “templates” later, not now

#### A3) Rules are first-class objects (no arbitrary limit)

* [ ] Rule fields (minimum viable)

  * [ ] `id`, `name`, `enabled`
  * [ ] expression root (tree)
  * [ ] `actions[]`
  * [ ] timing: `minEvalPeriodMs`, `cooldownMs`, `durationMs`
  * [ ] runtime: `lastEvalMs`, `lastTriggerMs`, `activeUntilMs`
* [ ] NVS storage: list/vector of rules (no 12-row table)

#### A4) Output conflict resolution (deterministic)

* [ ] Decide & implement one strategy (simple first)

  * [ ] **Priority** per rule OR deterministic ordering by `rule.id`
  * [ ] Optional merges later: max/min for PWM “demand”
* [ ] Add “manual override layer” above rules (so UI can force outputs)

---

### B) Refactor to match your current software architecture (keep it clean)

*(This is “make it modular without turning it into spaghetti.”)*

* [ ] **Engine modules**

  * [ ] `rule_model.*` (structs + serialization)
  * [ ] `conditions/*` (condition types)
  * [ ] `expr_tree.*` (AND/OR/NOT eval)
  * [ ] `actions/*` (set output, etc.)
  * [ ] `rules_engine.*` (scheduler + cooldown + apply)
* [ ] **Web UI separation stays intact**

  * [ ] `web_pages/*` = HTML builders only
  * [ ] `web_routes/*` = handlers only (POST/save/redirect)
* [ ] **Non-blocking deterministic loop**

  * [ ] No delays, no long handlers, predictable tick cadence

---

### C) Web UI to build rules (MVP first, fancy later)

#### C1) Pages (minimal viable workflow)

* [ ] `/rules` — list rules (enable/disable, edit, delete)
* [ ] `/rule/new` — create empty rule → redirect edit
* [ ] `/rule/edit?id=` — all-in-one editor:

  * [ ] expression editor (AND/OR/NOT + add condition leaves)
  * [ ] action editor (add action rows)
  * [ ] timing fields (minEvalPeriod/cooldown/duration)
* [ ] `/conditions` — list/create condition blocks
* [ ] `/condition/edit?id=` — condition constructor (type + params)

#### C2) UI philosophy (what to enforce)

* [ ] “Create blocks → assemble rule → save”
* [ ] No artificial rule count limit
* [ ] Rules are objects; condition blocks are reusable

---

### D) Starter condition library (so rules do real work quickly)

*(Pick 3–6 that immediately drive diversion behavior.)*

* [ ] `SunIsOut` (PV watts > X for stableForMs)
* [ ] `BatterySocAbove(threshold)` (with hysteresis)
* [ ] `WaterTempBelow(target)` (with hysteresis)
* [ ] `TankTempBelow(min)`
* [ ] `CommsHealthy(node)` / `AnyFault`
* [ ] `GridImporting` / `InverterLoadAbove` (if you expose that telemetry)

---

## Lower priority: comms, MQTT, “world interface module”, hardware planning

### E) ESP32-S3 as an MQTT broker (optional capability)

* [ ] Define scope: “small local broker” for a handful of nodes
* [ ] Broker mode is **optional** (compile-time or config flag)
* [ ] Decide: “brokerless by default” vs “broker enabled by default”
* [ ] Test matrix:

  * [ ] number of clients
  * [ ] retained messages usage
  * [ ] QoS level you actually need

### F) Brokerless comms options (no centralized hub vibe)

* [ ] Direct HTTP/REST + discovery (mDNS)
* [ ] WebSockets (push without MQTT)
* [ ] CoAP (lightweight UDP)
* [ ] ESP-NOW for local-only low-latency

### G) Universal “world interface module” (protocol gateway)

Goal: one module whose job is “talk to everything else,” normalize to your internal model.

#### G1) Southbound drivers (incremental)

* [ ] Victron Energy **VE.Direct UART**
* [ ] Victron Cerbo GX **GX Modbus-TCP** (if you want to read GX state centrally)
* [ ] **Modbus RTU over RS-485** for common inverters/controllers (Growatt-class)

  * [ ] Growatt profile
* [ ] CAN-based integrations (only after the above are solid)
* [ ] BMS integrations (pick winners by availability + protocol clarity)

  * [ ] JK BMS
  * [ ] JBD BMS
  * [ ] Ectrodacus
  * [ ] EG4 Electronics (if protocols are accessible)

#### G2) Normalized internal model (northbound to your rules)

* [ ] `Battery`: volts/amps/soc/temp/alarms
* [ ] `PV`: watts/volts/amps
* [ ] `Inverter`: load watts, mode, faults
* [ ] `System`: states, comms health
* [ ] Publish these into your existing IO catalog so rules can consume them

#### G3) Northbound transports (what your ecosystem consumes)

* [ ] Your RS-485 bus schema (already in your project)
* [ ] MQTT publish (if broker exists)
* [ ] HTTP endpoints for UI + debugging
* [ ] WebSocket streaming (nice for dashboards)

---

## Hardware design implications (so you can start drawing boards)

### H) Gateway / interface board (later phase, but start constraints now)

* [ ] Ports you’ll likely want:

  * [ ] 1–2× RS-485
  * [ ] 2–4× UART (VE.Direct + misc)
  * [ ] CAN transceiver
  * [ ] Isolated supply domains if you’re plugging into noisy systems
* [ ] “Field survivability” basics:

  * [ ] TVS, proper grounding strategy, connector choices, ESD
  * [ ] Clear separation: dirty power vs logic rails (you already do this)

---

## “Definition of Done” (so you can check boxes and feel progress)

### DoD for the **rules vNext** milestone

* [ ] Create condition blocks
* [ ] Assemble nested logic (AND/OR/NOT) in UI
* [ ] Attach actions
* [ ] Timing controls work (min eval + cooldown + duration)
* [ ] Deterministic output resolution
* [ ] Saved to NVS, survives reboot, no fixed rule limit

### DoD for the **gateway MVP** milestone

* [ ] One real-world telemetry source works end-to-end (start with VE.Direct)
* [ ] Values appear in IO catalog
* [ ] A rule can use that data to drive an output

---

If you want to make this even more “actionable tomorrow,” I can compress **Section A + C** into an ordered punch-list of ~10 commits (file-by-file) that fits your current repo structure and keeps the thin `.ino` approach intact.
